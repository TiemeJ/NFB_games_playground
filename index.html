<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>MyndBand Force Unlocker</title>
    <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
    <style>
        body { font-family: 'Segoe UI', sans-serif; background: #2d3436; color: #dfe6e9; display: flex; flex-direction: column; align-items: center; padding: 30px; }
        h1 { margin: 0; color: #0984e3; }
        .subtitle { color: #b2bec3; font-size: 0.9em; margin-bottom: 20px; }
        
        #status-box { padding: 10px 20px; background: #636e72; border-radius: 30px; font-weight: bold; color: #fff; margin-bottom: 20px; border: 1px solid #b2bec3; }
        .success { background: #00b894 !important; }
        .fail { background: #d63031 !important; }

        button { padding: 15px 40px; font-size: 18px; font-weight: bold; background: #0984e3; color: white; border: none; border-radius: 10px; cursor: pointer; margin-bottom: 20px; }
        button:hover { background: #74b9ff; }

        /* Scope */
        .scope-container { background: #000; border: 2px solid #0984e3; border-radius: 15px; width: 100%; max-width: 800px; height: 300px; position: relative; }
        canvas#rawScope { width: 100%; height: 100%; }
        .scope-overlay { position: absolute; top: 10px; left: 15px; color: #0f0; font-family: monospace; font-size: 12px; pointer-events: none; }

        /* Log */
        .log-container { width: 100%; max-width: 800px; margin-top: 20px; }
        pre#debug-log { background:#000; color:#0f0; padding:15px; border-radius:10px; height:200px; overflow-y:auto; font-size:11px; font-family:monospace; white-space:pre-wrap; border: 1px solid #444; }
    </style>
</head>
<body>

    <h1>üîì MyndBand Force Unlocker</h1>
    <div class="subtitle">Targeting Hidden Service 0xFFE0</div>
    
    <div id="status-box">Ready</div>
    <button id="connectBtn">SCAN FOR HIDDEN SERVICE</button>

    <div class="scope-container">
        <div class="scope-overlay">RAW DATA (512Hz) | Signal: <span id="sig-val">--</span></div>
        <canvas id="rawScope"></canvas>
    </div>

    <div class="log-container">
        <div style="display:flex; justify-content:space-between; color:#b2bec3; margin-bottom:5px;">
            <span>Packet Sniffer</span>
            <span style="cursor:pointer;" onclick="document.getElementById('debug-log').innerText=''">[Clear]</span>
        </div>
        <pre id="debug-log">Waiting...</pre>
    </div>

    <script>
        const TARGET_SERVICE = "0000ffe0-0000-1000-8000-00805f9b34fb";
        const TARGET_CHAR    = "0000ffe1-0000-1000-8000-00805f9b34fb";
        
        // Fallback (The one that works for connection but maybe not unlock)
        const NATIVE_SERVICE = "039afff0-2c94-11e3-9e06-0002a5d5c51b";

        const btn = document.getElementById('connectBtn');
        const statusBox = document.getElementById('status-box');
        const debugLog = document.getElementById('debug-log');
        let sniffCount = 0;

        function log(msg) {
            console.log(msg);
            const ts = new Date().toLocaleTimeString().split(' ')[0];
            debugLog.innerText += `\n[${ts}] ${msg}`;
            debugLog.scrollTop = debugLog.scrollHeight;
        }

        // --- VISUALIZER ---
        const canvas = document.getElementById('rawScope');
        const ctx = canvas.getContext('2d');
        let rawBuffer = new Array(512).fill(0);
        
        function resize() { canvas.width = canvas.offsetWidth; canvas.height = canvas.offsetHeight; }
        window.addEventListener('resize', resize); resize();

        function draw() {
            const w = canvas.width, h = canvas.height, mid = h/2, scale = h/1000;
            ctx.fillStyle = "rgba(0,0,0,0.2)"; // Fade effect
            ctx.fillRect(0,0,w,h);
            ctx.lineWidth = 2; ctx.strokeStyle = "#00ff00"; ctx.beginPath();
            const step = w/rawBuffer.length;
            for(let i=0; i<rawBuffer.length; i++) {
                const y = mid - (rawBuffer[i] * scale);
                if(i===0) ctx.moveTo(i*step, y); else ctx.lineTo(i*step, y);
            }
            ctx.stroke();
            requestAnimationFrame(draw);
        }
        draw();

        // --- BLUETOOTH CORE ---
        btn.addEventListener('click', async () => {
            try {
                statusBox.innerText = "Scanning (Select device with no name if needed)...";
                sniffCount = 0;

                // STRATEGY: Look for the specific Serial Service first
                const device = await navigator.bluetooth.requestDevice({
                    // acceptingAllDevices: true, // Risky in some browsers, trying specific filter first
                    filters: [
                        { services: [TARGET_SERVICE] },      // Priority 1: The Hidden Service
                        { namePrefix: 'Mynd' },              // Priority 2: Standard Name
                        { namePrefix: 'Mind' }
                    ],
                    optionalServices: [TARGET_SERVICE, NATIVE_SERVICE]
                });

                statusBox.innerText = "Connecting...";
                const server = await device.gatt.connect();
                let charToUse = null;

                // 1. HUNT FOR FFE1 (The Magic Key)
                try {
                    log("üïµÔ∏è Looking for Hidden Service ffe0...");
                    const service = await server.getPrimaryService(TARGET_SERVICE);
                    charToUse = await service.getCharacteristic(TARGET_CHAR);
                    log("üéâ FOUND HIDDEN FFE1! This is the main serial line.");
                } catch(e) {
                    log("‚ùå Hidden Service not accessible.");
                    
                    // 2. FALLBACK TO NATIVE
                    log("‚ö†Ô∏è Trying Native Service fff4/fff8...");
                    try {
                        const service = await server.getPrimaryService(NATIVE_SERVICE);
                        const chars = await service.getCharacteristics();
                        
                        // We will try to WRITE to fff4 and READ from fff8
                        const cmdChar = chars.find(c => c.uuid.includes("fff4"));
                        const dataChar = chars.find(c => c.uuid.includes("fff8"));
                        
                        if (cmdChar && dataChar) {
                            charToUse = { write: cmdChar, read: dataChar };
                            log("‚úÖ Using Native Split Channels.");
                        } else {
                            throw new Error("Native characteristics missing");
                        }
                    } catch(err2) {
                        throw new Error("No usable services found. Is headset ON?");
                    }
                }

                // 3. SETUP LISTENER
                const readNode = (charToUse.read) ? charToUse.read : charToUse;
                await readNode.startNotifications();
                readNode.addEventListener('characteristicvaluechanged', handleData);
                log("üëÇ Listening for stream...");

                // 4. THE UNLOCK COMMANDS (Try Variations)
                const writeNode = (charToUse.write) ? charToUse.write : charToUse;
                
                log("üöÄ Sending Unlock Sequence (0x02)...");
                const cmd = new Uint8Array([0x02]); // Command: Change baud to 57600
                
                try {
                    if (writeNode.properties.write) await writeNode.writeValueWithResponse(cmd);
                    else await writeNode.writeValueWithoutResponse(cmd);
                    log("‚úÖ Command Sent.");
                } catch(err) {
                    log("‚ö†Ô∏è Write failed: " + err.message);
                }

                statusBox.innerText = "Connected & Unlocked?";
                statusBox.className = "success";

            } catch(e) {
                log("üî• Error: " + e.message);
                statusBox.innerText = "Connection Failed";
                statusBox.className = "fail";
            }
        });

        // --- PARSER ---
        let parseBuffer = [];
        function handleData(event) {
            const chunk = new Uint8Array(event.target.value.buffer);
            
            // Log first few packets to see if format changes
            if (sniffCount < 10) {
                const hex = Array.from(chunk).map(b => b.toString(16).padStart(2,'0').toUpperCase()).join(' ');
                log(`üì¶ ${hex}`);
                sniffCount++;
            }

            for(let i=0; i<chunk.length; i++) parseBuffer.push(chunk[i]);
            
            while(parseBuffer.length > 0) {
                const b = parseBuffer[0];
                
                // 1. SYNC (AA AA)
                if(b === 0xAA) {
                    if(parseBuffer.length > 1 && parseBuffer[1] === 0xAA) {
                        // Full packet logic would go here
                        // For raw mode, we just want to see if we get here
                        parseBuffer.shift(); parseBuffer.shift(); 
                        continue;
                    } else if (parseBuffer.length > 1) { parseBuffer.shift(); continue; }
                    else return;
                }
                
                // 2. RAW BYTE (0x80) - The Holy Grail
                else if (b === 0x80) {
                    if(parseBuffer.length < 4) return;
                    if(parseBuffer[1] === 0x02) {
                        // WE HAVE RAW DATA!
                        const val = (parseBuffer[2] << 8) | parseBuffer[3];
                        updateScope(val);
                        parseBuffer.splice(0, 4);
                        continue;
                    }
                }
                
                // 3. SIGNAL BYTE (0x02)
                else if (b === 0x02 && parseBuffer.length >= 2) {
                    const sig = parseBuffer[1];
                    document.getElementById('sig-val').innerText = sig;
                    parseBuffer.splice(0, 2);
                }

                // 4. MYNDBAND WRAPPER (00 00 EA...)
                else if (b === 0x00 && parseBuffer.length >= 3 && parseBuffer[2] === 0xEA) {
                     // Extract signal from wrapper
                     // 00 00 EA 00 00 02 [SIG]
                     if (parseBuffer.length >= 20) {
                        const sig = parseBuffer[6];
                        document.getElementById('sig-val').innerText = sig;
                        parseBuffer.splice(0, 20); // Eat the wrapper
                     } else return;
                }
                
                else {
                    parseBuffer.shift();
                }
            }
        }

        function updateScope(val) {
            if (val > 32768) val -= 65536;
            rawBuffer.shift();
            rawBuffer.push(val);
        }

    </script>
</body>
</html>
