<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>NeuroScope V9: Exact Replay</title>
    <style>
        :root { --bg: #121212; --panel: #1e1e1e; --accent: #00e5ff; --text: #eee; }
        body { font-family: 'Consolas', monospace; background: var(--bg); color: var(--text); padding: 20px; display: flex; flex-direction: column; align-items: center; }
        
        h1 { border-bottom: 2px solid var(--accent); padding-bottom: 10px; color: #fff; }
        button { background: var(--accent); color: #000; font-size: 16px; padding: 15px 30px; border: none; font-weight: bold; cursor: pointer; margin-bottom: 20px; }
        button:disabled { background: #444; color: #888; cursor: default; }

        .grid { display: grid; grid-template-columns: 1fr 1fr; gap: 20px; width: 100%; max-width: 900px; }
        .card { background: var(--panel); padding: 15px; border: 1px solid #333; }

        /* Stats */
        .stat-val { font-size: 2em; font-weight: bold; color: #fff; }
        .stat-lbl { color: var(--accent); font-size: 0.8em; text-transform: uppercase; }

        /* Hex Dump */
        #hex-dump { 
            height: 150px; 
            font-size: 11px; 
            color: #0f0; 
            background: #000; 
            padding: 10px; 
            overflow-y: auto; 
            word-break: break-all; 
            border: 1px solid #333; 
            font-family: 'Courier New', monospace;
        }

        /* Canvas */
        .scope-wrap { height: 300px; background: #000; border: 1px solid #333; position: relative; margin-top: 20px; }
        canvas { width: 100%; height: 100%; display: block; }

        /* Log */
        #sys-log { margin-top: 10px; color: #666; font-size: 0.9em; max-width: 900px; width: 100%; }
    </style>
</head>
<body>

    <h1>NEUROSCOPE V9</h1>
    <div style="margin-bottom: 20px; color: #888;">Protocol: Explicit Write Request (With Response)</div>

    <button id="btn">CONNECT & REPLAY ANDROID LOG</button>

    <div class="grid">
        <div class="card">
            <div class="stat-val" id="pps">0</div>
            <div class="stat-lbl">Packets Per Second</div>
        </div>
        
        <div class="card">
            <div style="margin-bottom: 5px; color: #aaa; font-size: 0.8em;">INCOMING RAW HEX (FIRST 1000 BYTES)</div>
            <div id="hex-dump">Waiting for stream...</div>
        </div>
    </div>

    <div class="scope-wrap" style="width: 100%; max-width: 900px;">
        <canvas id="graph"></canvas>
    </div>

    <div id="sys-log">System Ready.</div>

    <script>
        // ════ CONFIG ════
        // The exact UUIDs from your log analysis
        const SERVICE_UUID = "0000ffe0-0000-1000-8000-00805f9b34fb";
        const CHAR_UUID    = "0000ffe1-0000-1000-8000-00805f9b34fb";
        
        // Also listen to standard just in case
        const MYND_UUID    = "039afff0-2c94-11e3-9e06-0002a5d5c51b";

        // ════ STATE ════
        let rawBuffer = new Array(512).fill(0);
        let packetCount = 0;
        let byteLogCount = 0;

        // ════ UI ════
        const btn = document.getElementById('btn');
        const hexEl = document.getElementById('hex-dump');
        const ppsEl = document.getElementById('pps');
        const logEl = document.getElementById('sys-log');
        const cvs = document.getElementById('graph');
        const ctx = cvs.getContext('2d');

        function log(msg) { logEl.innerText = "> " + msg; }
        function resize() { cvs.width = cvs.parentElement.clientWidth; cvs.height = cvs.parentElement.clientHeight; }
        window.addEventListener('resize', resize);
        resize();

        // ════ MAIN ════
        btn.addEventListener('click', async () => {
            try {
                log("Scanning...");
                const device = await navigator.bluetooth.requestDevice({
                    filters: [{ namePrefix: 'Mynd' }, { namePrefix: 'Mind' }, { namePrefix: 'Brain' }],
                    optionalServices: [SERVICE_UUID, MYND_UUID]
                });

                log("Connecting...");
                const server = await device.gatt.connect();
                
                // 1. GET SERIAL SERVICE
                log("Getting Serial Service (FFE0)...");
                const service = await server.getPrimaryService(SERVICE_UUID);
                const char = await service.getCharacteristic(CHAR_UUID);
                log("Found Serial Characteristic (FFE1).");

                // 2. START NOTIFICATIONS FIRST (Like Android)
                await char.startNotifications();
                char.addEventListener('characteristicvaluechanged', handleData);
                log("Listening started.");

                // 3. SEND COMMAND (Strict Mode)
                log("Sending 0x02 (Write With Response)...");
                const cmd = new Uint8Array([0x02]);
                
                // IMPORTANT: We use writeValue (With Response) because the log showed a 'Write Request'
                await char.writeValue(cmd);
                
                log("Command Sent! Waiting for flood...");
                btn.disabled = true;
                btn.innerText = "RUNNING";

                // Loops
                requestAnimationFrame(draw);
                setInterval(() => {
                    ppsEl.innerText = packetCount;
                    packetCount = 0;
                }, 1000);

            } catch (e) {
                log("ERROR: " + e.message);
                hexEl.innerText += "\nERROR: " + e.message;
            }
        });

        // ════ PARSER ════
        let buffer = [];

        function handleData(event) {
            const data = new Uint8Array(event.target.value.buffer);
            packetCount++;

            // 1. HEX SPY (Debug)
            if (byteLogCount < 500) { // Only log first 500 bytes to save CPU
                let s = "";
                for(let b of data) s += b.toString(16).padStart(2,'0').toUpperCase() + " ";
                hexEl.innerText += s;
                byteLogCount += data.length;
            }

            // 2. BUFFER
            for (let i=0; i<data.length; i++) buffer.push(data[i]);
            if (buffer.length > 2048) buffer.splice(0, 1024);

            processBuffer();
        }

        function processBuffer() {
            while (buffer.length >= 4) {
                // Look for 0x80 Raw Packet (Common in Serial Streams)
                // Serial streams often strip the 'AA AA' sync bytes to save bandwidth
                // Format often: [80] [02] [High] [Low]
                
                if (buffer[0] === 0x80 && buffer[1] === 0x02) {
                    const val = (buffer[2] << 8) | buffer[3];
                    pushVal(val);
                    buffer.splice(0, 4); // Consume 4 bytes
                    continue;
                }

                // Look for Standard 'AA AA' Sync (Just in case)
                if (buffer[0] === 0xAA && buffer[1] === 0xAA) {
                    const len = buffer[2];
                    if (buffer.length >= 3 + len + 1) {
                        const payload = buffer.slice(3, 3+len);
                        parsePayload(payload);
                        buffer.splice(0, 3+len+1);
                        continue;
                    } else {
                        return; // Wait for data
                    }
                }

                buffer.shift(); // No match, slide 1 byte
            }
        }

        function parsePayload(payload) {
            for(let i=0; i<payload.length-3; i++) {
                if(payload[i] === 0x80) {
                     const val = (payload[i+2] << 8) | payload[i+3];
                     pushVal(val);
                     return;
                }
            }
        }

        function pushVal(raw) {
            if (raw >= 32768) raw -= 65536;
            rawBuffer.push(raw);
            rawBuffer.shift();
        }

        // ════ DRAW ════
        function draw() {
            ctx.fillStyle = "#000";
            ctx.fillRect(0, 0, cvs.width, cvs.height);
            ctx.strokeStyle = "#00e5ff";
            ctx.lineWidth = 1.5;
            ctx.beginPath();
            
            const w = cvs.width;
            const h = cvs.height;
            const step = w / rawBuffer.length;
            const mid = h / 2;

            for (let i=0; i<rawBuffer.length; i++) {
                const y = mid - (rawBuffer[i] * (h/4000));
                if (i===0) ctx.moveTo(i*step, y);
                else ctx.lineTo(i*step, y);
            }
            ctx.stroke();
            requestAnimationFrame(draw);
        }
    </script>
</body>
</html>
