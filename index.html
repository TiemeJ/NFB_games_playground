<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>MyndBand Shotgun Unlocker</title>
    <style>
        body { font-family: 'Segoe UI', monospace; background: #1e272e; color: #d2dae2; display: flex; flex-direction: column; align-items: center; padding: 20px; }
        h1 { margin: 0; color: #ff9f43; text-shadow: 0 0 10px rgba(255, 159, 67, 0.5); }
        .subtitle { color: #808e9b; font-size: 0.9em; margin-bottom: 20px; }
        
        /* Signal Indicator */
        #sig-box { 
            padding: 15px 30px; border-radius: 10px; font-size: 24px; font-weight: bold; 
            margin-bottom: 20px; text-align: center; border: 2px solid #576574;
            transition: all 0.3s ease;
        }
        .sig-off { background: #ff3f34; color: #fff; box-shadow: 0 0 15px #ff3f34; } 
        .sig-ok  { background: #ffa801; color: #000; } 
        .sig-good{ background: #0be881; color: #000; box-shadow: 0 0 15px #0be881; } 

        button { padding: 15px 50px; font-size: 20px; font-weight: bold; background: #0984e3; color: white; border: none; border-radius: 50px; cursor: pointer; transition: 0.2s; box-shadow: 0 5px 15px rgba(0,0,0,0.3); }
        button:hover { transform: scale(1.05); background: #3498db; }
        button:disabled { background: #485460; transform: none; color: #808e9b; }

        /* Oscilloscope */
        .scope-container { 
            background: #000; border: 3px solid #ff9f43; border-radius: 15px; 
            width: 100%; max-width: 900px; height: 350px; position: relative; 
            box-shadow: inset 0 0 20px rgba(0,0,0,0.8);
        }
        canvas#rawScope { width: 100%; height: 100%; display: block; }
        .scope-overlay { position: absolute; top: 10px; left: 15px; color: #ff9f43; font-size: 12px; pointer-events: none; }
        
        #log { width: 100%; max-width: 900px; height: 150px; background: #000; color: #0f0; padding: 10px; margin-top: 15px; overflow-y: scroll; border: 1px solid #333; font-size: 11px; }
    </style>
</head>
<body>

    <h1>ðŸ’¥ MyndBand Shotgun Unlocker</h1>
    <div class="subtitle">Writing 0x02 to ALL Channels (fff4 & fff8)</div>

    <div id="sig-box" class="sig-off">SIGNAL: --</div>
    <button id="connectBtn">CONNECT</button>
    <button id="manualUnlock" style="background:#444; font-size:14px; padding:8px 20px; margin-top:10px;" onclick="forceFire()">Manual Trigger (Fire 0x02)</button>

    <div class="scope-container" style="margin-top: 20px;">
        <div class="scope-overlay">RAW STREAM (512Hz)</div>
        <canvas id="rawScope"></canvas>
    </div>

    <pre id="log">Waiting...</pre>

    <script>
        const NATIVE_SERVICE = "039afff0-2c94-11e3-9e06-0002a5d5c51b";
        const HM10_SERVICE   = "0000ffe0-0000-1000-8000-00805f9b34fb";
        
        const btn = document.getElementById('connectBtn');
        const sigBox = document.getElementById('sig-box');
        const logBox = document.getElementById('log');
        
        let writeChars = []; // Array to hold ALL writable characteristics
        let isRawUnlocked = false;
        let lastSignal = 200;
        let retryInterval = null;

        function log(msg) {
            const time = new Date().toLocaleTimeString().split(' ')[0];
            logBox.innerText += `\n[${time}] ${msg}`;
            logBox.scrollTop = logBox.scrollHeight;
        }

        // --- SCOPE VISUALIZER ---
        const canvas = document.getElementById('rawScope');
        const ctx = canvas.getContext('2d');
        let rawBuffer = new Array(512).fill(0);
        
        function resize() { canvas.width = canvas.offsetWidth; canvas.height = canvas.offsetHeight; }
        window.addEventListener('resize', resize); resize();

        function draw() {
            const w = canvas.width, h = canvas.height, mid = h/2, scale = h/1500;
            ctx.fillStyle = "rgba(0,0,0,0.2)";
            ctx.fillRect(0,0,w,h);
            
            ctx.lineWidth = 2; 
            ctx.strokeStyle = isRawUnlocked ? "#ff9f43" : "#485460"; 
            ctx.beginPath();
            
            const step = w/rawBuffer.length;
            for(let i=0; i<rawBuffer.length; i++) {
                const y = mid - (rawBuffer[i] * scale);
                if(i===0) ctx.moveTo(i*step, y); else ctx.lineTo(i*step, y);
            }
            ctx.stroke();
            requestAnimationFrame(draw);
        }
        draw();

        // --- CONNECT ---
        btn.addEventListener('click', async () => {
            try {
                sigBox.innerText = "Scanning...";
                const device = await navigator.bluetooth.requestDevice({
                    filters: [{ namePrefix: 'Mynd' }, { namePrefix: 'Mind' }, { namePrefix: 'Brain' }],
                    optionalServices: [NATIVE_SERVICE, HM10_SERVICE, "0000ffe0-0000-1000-8000-00805f9b34fb"]
                });

                const server = await device.gatt.connect();
                log("Connected to GATT Server.");

                // RESET
                writeChars = [];

                // 1. HARVEST NATIVE CHANNELS
                try {
                    const service = await server.getPrimaryService(NATIVE_SERVICE);
                    const chars = await service.getCharacteristics();
                    
                    // Add FFF4 (Command)
                    const c4 = chars.find(c => c.uuid.includes("fff4"));
                    if(c4) { writeChars.push(c4); log("âœ… Target Acquired: fff4"); }

                    // Add FFF8 (Data - sometimes also Write!)
                    const c8 = chars.find(c => c.uuid.includes("fff8"));
                    if(c8) { 
                        writeChars.push(c8); 
                        log("âœ… Target Acquired: fff8"); 
                        // Start listening on 8
                        await c8.startNotifications();
                        c8.addEventListener('characteristicvaluechanged', handleData);
                    }
                    
                } catch(e) { log("âš ï¸ Native Scan incomplete: " + e.message); }

                // 2. HARVEST HM-10 (If available)
                try {
                    const service = await server.getPrimaryService(HM10_SERVICE);
                    const cE1 = await service.getCharacteristic("0000ffe1-0000-1000-8000-00805f9b34fb");
                    if(cE1) {
                        writeChars.push(cE1);
                        log("âœ… Target Acquired: ffe1 (HM-10)");
                        // Start listening on HM-10 too just in case
                        await cE1.startNotifications();
                        cE1.addEventListener('characteristicvaluechanged', handleData);
                    }
                } catch(e) { /* ignore */ }

                if(writeChars.length === 0) throw new Error("No writable channels found!");

                btn.disabled = true;
                btn.innerText = "Connected";
                startUnlockLoop();

            } catch(e) {
                log("Error: " + e.message);
                sigBox.innerText = "Error";
            }
        });

        // --- THE "SHOTGUN" FIRE FUNCTION ---
        async function forceFire() {
            const cmd = new Uint8Array([0x02]);
            log(`ðŸ”¥ Firing 0x02 to ${writeChars.length} channels...`);
            
            for (const char of writeChars) {
                try {
                    const uuidShort = char.uuid.substring(4,8);
                    if(char.properties.write) await char.writeValueWithResponse(cmd);
                    else if(char.properties.writeWithoutResponse) await char.writeValueWithoutResponse(cmd);
                    log(`   -> Sent to ${uuidShort}`);
                } catch(e) {
                    log(`   X Failed ${char.uuid.substring(4,8)}: ${e.message}`);
                }
            }
        }
        window.forceFire = forceFire;

        // --- RETRY LOGIC ---
        function startUnlockLoop() {
            // Rapid fire every 500ms
            retryInterval = setInterval(async () => {
                if (isRawUnlocked) return; 

                if (lastSignal === 200) {
                    log("ðŸš« Waiting for Signal < 200...");
                    return; 
                }

                await forceFire();

            }, 500); // 500ms interval
        }

        // --- PARSER ---
        let parseBuffer = [];

        function handleData(event) {
            const chunk = new Uint8Array(event.target.value.buffer);
            for(let i=0; i<chunk.length; i++) parseBuffer.push(chunk[i]);
            processBuffer();
        }

        function processBuffer() {
            while(parseBuffer.length > 0) {
                const b = parseBuffer[0];

                // 1. RAW MODE PACKET (0x80) -> SUCCESS!
                if (b === 0x80) {
                    if(parseBuffer.length < 4) return;
                    if(parseBuffer[1] === 0x02) {
                        if (!isRawUnlocked) {
                            isRawUnlocked = true;
                            log("ðŸŽ‰ RAW MODE UNLOCKED! (Stream Active)");
                            clearInterval(retryInterval); 
                        }
                        const val = (parseBuffer[2] << 8) | parseBuffer[3];
                        updateScope(val);
                        parseBuffer.splice(0, 4);
                        continue;
                    }
                }
                
                // 2. STANDARD MODE PACKET (Sync AA AA)
                else if (b === 0xAA) {
                    if(parseBuffer.length >= 2 && parseBuffer[1] === 0xAA) {
                        if(parseBuffer.length < 4) return;
                        const len = parseBuffer[2];
                        if(parseBuffer.length < 3 + len + 1) return;
                        const payload = parseBuffer.slice(3, 3+len);
                        parseStandardPayload(payload);
                        parseBuffer.splice(0, 3 + len + 1);
                        continue;
                    } else {
                        if(parseBuffer.length >= 2 && parseBuffer[1] !== 0xAA) { parseBuffer.shift(); continue; }
                        if(parseBuffer.length < 2) return;
                    }
                }
                
                // 3. MYNDBAND WRAPPER (00 00 EA...)
                else if (b === 0x00 && parseBuffer.length >= 3 && parseBuffer[2] === 0xEA) {
                     if (parseBuffer.length >= 7) {
                        const sig = parseBuffer[6];
                        updateSignalUI(sig);
                        parseBuffer.splice(0, 3); 
                     } else return;
                }

                else if (b === 0x02 && parseBuffer.length >= 2) {
                    if (parseBuffer[1] <= 200) {
                        updateSignalUI(parseBuffer[1]);
                        parseBuffer.splice(0, 2);
                        continue;
                    }
                }
                
                else {
                    parseBuffer.shift();
                }
            }
        }

        function parseStandardPayload(payload) {
            for(let i=0; i<payload.length; i++) {
                if (payload[i] === 0x02) {
                    updateSignalUI(payload[i+1]);
                    return;
                }
            }
        }

        function updateSignalUI(sig) {
            lastSignal = sig;
            sigBox.innerText = `SIGNAL: ${sig}`;
            if (sig === 200) { sigBox.className = "sig-off"; sigBox.innerText += " (Check Fit)"; }
            else if (sig === 0) { sigBox.className = "sig-good"; sigBox.innerText += " (Perfect)"; }
            else { sigBox.className = "sig-ok"; sigBox.innerText += " (Noise)"; }
        }

        function updateScope(val) {
            if (val > 32768) val -= 65536;
            rawBuffer.shift();
            rawBuffer.push(val);
        }
    </script>
</body>
</html>
