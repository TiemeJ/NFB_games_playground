<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>MyndBand Universal Scanner</title>
    <style>
        body { font-family: monospace; background: #1a1a1a; color: #00ff00; padding: 20px; max-width: 800px; margin: 0 auto; }
        h1 { color: #fff; border-bottom: 1px solid #444; padding-bottom: 10px; }
        button { font-family: monospace; padding: 15px 30px; font-size: 16px; background: #00ff00; color: black; border: none; cursor: pointer; font-weight: bold; margin-bottom: 20px; }
        button:hover { background: #00cc00; }
        
        #dashboard { display: grid; grid-template-columns: 1fr 1fr; gap: 10px; margin-bottom: 20px; }
        .stat-box { border: 1px solid #444; padding: 15px; background: #222; }
        .stat-label { color: #888; font-size: 0.8em; }
        .stat-val { font-size: 2em; color: #fff; }

        #log { background: #000; padding: 15px; height: 300px; overflow-y: scroll; border: 1px solid #333; white-space: pre-wrap; font-size: 0.9em; }
        .highlight { color: #ffff00; font-weight: bold; }
        .error { color: #ff5555; }
        .success { color: #00ff00; font-weight: bold; }
    </style>
</head>
<body>

    <h1>ðŸ§  MyndBand Universal Scanner</h1>
    <p>1. Unpair from Windows Settings first.<br>2. Put headset in pairing mode (Fast Blink).<br>3. Click Connect.</p>
    
    <button id="connectBtn">SCAN & CONNECT</button>

    <div id="dashboard">
        <div class="stat-box"><div class="stat-label">ATTENTION</div><div class="stat-val" id="att">--</div></div>
        <div class="stat-box"><div class="stat-label">MEDITATION</div><div class="stat-val" id="med">--</div></div>
        <div class="stat-box"><div class="stat-label">SIGNAL</div><div class="stat-val" id="sig">--</div></div>
        <div class="stat-box"><div class="stat-label">RAW WAVE</div><div class="stat-val" id="raw">--</div></div>
    </div>

    <div id="log">Logs will appear here...</div>

    <script>
        const logEl = document.getElementById('log');
        const connectBtn = document.getElementById('connectBtn');
        
        // Comprehensive list of Serial-over-BLE Service UUIDs
        const SERVICE_LIST = [
            "0000fe41-0000-1000-8000-00805f9b34fb", // NeuroSky Standard
            "0000ffe0-0000-1000-8000-00805f9b34fb", // HM-10 / JDY-08 (Common in clones)
            "6e400001-b5a3-f393-e0a9-e50e24dcca9e", // Nordic UART
            "49535343-fe7d-4ae5-8fa9-9fafd205e455", // Microchip Transparent
            "00001101-0000-1000-8000-00805f9b34fb"  // Generic Serial
        ];

        function log(msg, type = '') {
            const line = document.createElement('div');
            line.textContent = `> ${msg}`;
            if(type) line.className = type;
            logEl.appendChild(line);
            logEl.scrollTop = logEl.scrollHeight;
        }

        connectBtn.addEventListener('click', async () => {
            try {
                log("Starting Scan...", "highlight");

                // 1. Request Device with ALL known serial services
                // We use acceptAllDevices: true to find it even if the name is weird
                const device = await navigator.bluetooth.requestDevice({
                    acceptAllDevices: true, 
                    optionalServices: SERVICE_LIST
                });

                log(`Device Selected: "${device.name}"`, "highlight");

                // 2. Connect to GATT
                const server = await device.gatt.connect();
                log("Connected to GATT Server. Scanning Services...");

                // 3. Find THE Service
                // We cannot list all services, only the ones we asked for in optionalServices.
                // We will try to get each one.
                
                let foundService = null;
                let foundChar = null;

                const services = await server.getPrimaryServices();
                log(`Device offers ${services.length} authorized services.`);

                for (const service of services) {
                    log(`Checking Service: ${service.uuid}`);
                    
                    try {
                        const chars = await service.getCharacteristics();
                        for (const char of chars) {
                            log(`  - Found Char: ${char.uuid} [Props: ${Object.keys(char.properties).filter(k=>char.properties[k]).join(',')}]`);
                            
                            // We need a characteristic that supports NOTIFY
                            if (char.properties.notify) {
                                log(`  >>> MATCH! Found Data Stream!`, "success");
                                foundService = service;
                                foundChar = char;
                                break; 
                            }
                        }
                    } catch(e) {
                        log(`  - Error checking chars: ${e}`);
                    }
                    if (foundChar) break;
                }

                if (!foundChar) {
                    throw new Error("Connected, but no Serial/Notify characteristic found in known services.");
                }

                // 4. Start Streaming
                log("Starting Notifications...", "highlight");
                await foundChar.startNotifications();
                foundChar.addEventListener('characteristicvaluechanged', handleData);
                log("LISTENING FOR DATA...", "success");
                connectBtn.disabled = true;
                connectBtn.innerText = "CONNECTED";

            } catch (err) {
                log(`ERROR: ${err.message}`, "error");
                if(err.message.includes("no Serial")) {
                    log("Tip: Try unpairing the device from Windows settings first.");
                }
            }
        });

        // --- PARSER ---
        let buffer = [];
        
        function handleData(event) {
            const data = new Uint8Array(event.target.value.buffer);
            data.forEach(b => buffer.push(b));
            
            // Keep buffer reasonable
            if (buffer.length > 512) buffer.shift();

            while (buffer.length >= 3) {
                // Look for Sync [AA, AA]
                if (buffer[0] !== 0xAA || buffer[1] !== 0xAA) {
                    buffer.shift();
                    continue;
                }

                const len = buffer[2];
                if (buffer.length < 3 + len + 1) break; // Wait for more data

                const payload = buffer.slice(3, 3 + len);
                const checksum = buffer[3 + len];
                const sum = payload.reduce((a, b) => a + b, 0);
                
                if (((~sum) & 0xFF) === checksum) {
                    parsePacket(payload);
                } else {
                    log("Checksum fail", "error");
                }
                
                buffer.splice(0, 3 + len + 1);
            }
        }

        function parsePacket(payload) {
            let i = 0;
            while (i < payload.length) {
                const code = payload[i++];
                if (code === 0x02) { // Signal Quality
                    const val = payload[i++];
                    document.getElementById('sig').innerText = val === 0 ? "GOOD" : (val === 200 ? "OFF" : val);
                    document.getElementById('sig').style.color = val === 0 ? "#00ff00" : "#ff5555";
                } 
                else if (code === 0x04) document.getElementById('att').innerText = payload[i++];
                else if (code === 0x05) document.getElementById('med').innerText = payload[i++];
                else if (code === 0x80) { // Raw Wave (2 bytes)
                    i++; // length
                    const val = (payload[i++] << 8) | payload[i++];
                    const raw = val >= 32768 ? val - 65536 : val;
                    document.getElementById('raw').innerText = raw;
                } 
                else if (code === 0x83) { // Bands (24 bytes)
                    i += 25; 
                }
                else {
                    // Unknown code, exit to prevent desync
                    break;
                }
            }
        }
    </script>
</body>
</html>
