<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>MyndBand Sniffer & Visualizer</title>
    <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
    <style>
        body { font-family: 'Segoe UI', sans-serif; background: #f0f2f5; display: flex; flex-direction: column; align-items: center; padding: 30px; color: #333; }
        h1 { margin: 0; color: #2d3436; }
        .subtitle { color: #636e72; font-size: 0.9em; margin-bottom: 20px; }
        #status-box { padding: 10px 20px; background: #dfe6e9; border-radius: 30px; font-weight: bold; color: #636e72; margin-bottom: 20px; }
        .connected { background: #00b894 !important; color: #fff !important; }
        button { padding: 15px 40px; font-size: 18px; font-weight: bold; background: #0984e3; color: white; border: none; border-radius: 10px; cursor: pointer; }
        button:disabled { background: #b2bec3; }
        .dashboard { display: grid; grid-template-columns: 1fr 1fr; gap: 20px; width: 100%; max-width: 800px; margin-top: 20px; }
        .card { background: white; padding: 25px; border-radius: 15px; text-align: center; box-shadow: 0 5px 15px rgba(0,0,0,0.05); }
        .value { font-size: 3em; font-weight: bold; color: #2d3436; }
        .scope-container { background: #000; padding: 10px; border-radius: 15px; width: 100%; max-width: 800px; height: 250px; position: relative; margin-top: 20px; }
        canvas#rawScope { width: 100%; height: 100%; }
        .scope-overlay { position: absolute; top: 10px; left: 15px; color: #0f0; font-family: monospace; font-size: 12px; }
        .section-header { font-size: 1.3em; font-weight: bold; margin-top: 30px; width: 100%; max-width: 800px; }
        pre#debug-log { background:#1e1e1e; color:#0f0; padding:15px; border-radius:10px; width:100%; max-width:800px; height:300px; overflow-y:auto; font-size:12px; font-family:monospace; white-space:pre-wrap; word-break:break-all; }
    </style>
</head>
<body>

    <h1>‚ö° MyndBand Sniffer</h1>
    <div class="subtitle">Diagnostic Tool: Inspects Incoming Bytes</div>
    
    <div id="status-box">Ready</div>
    <button id="connectBtn">CONNECT & SNIFF</button>

    <div class="section-header">‚ö° Raw Signal</div>
    <div class="scope-container">
        <div class="scope-overlay">BUFFER: 512Hz | Last Val: <span id="last-raw">0</span></div>
        <canvas id="rawScope"></canvas>
    </div>

    <div class="dashboard">
        <div class="card"><div class="label">Signal</div><div class="value" id="sig-val">--</div></div>
        <div class="card"><div class="label">Focus</div><div class="value" id="att-val">0</div></div>
    </div>

    <div class="section-header">üîç Data Stream Inspector</div>
    <pre id="debug-log">Waiting for connection...</pre>

    <script>
        const HM10_SERVICE = "0000ffe0-0000-1000-8000-00805f9b34fb";
        const OLD_SERVICE  = "039afff0-2c94-11e3-9e06-0002a5d5c51b";
        const btn = document.getElementById('connectBtn');
        const statusBox = document.getElementById('status-box');
        const debugLog = document.getElementById('debug-log');
        let sniffCount = 0; // Only log first 20 packets to avoid spam

        function log(msg) {
            console.log(msg);
            debugLog.innerText += "\n" + msg;
            debugLog.scrollTop = debugLog.scrollHeight;
        }

        // SCOPE
        const scopeCanvas = document.getElementById('rawScope');
        const ctx = scopeCanvas.getContext('2d');
        let rawBuffer = new Array(512).fill(0);
        function resizeScope() { scopeCanvas.width = scopeCanvas.offsetWidth; scopeCanvas.height = scopeCanvas.offsetHeight; }
        window.addEventListener('resize', resizeScope); resizeScope();
        function drawScope() {
            const w = scopeCanvas.width; const h = scopeCanvas.height; const mid = h/2; const scale = h/2000;
            ctx.fillStyle = "#000"; ctx.fillRect(0, 0, w, h);
            ctx.lineWidth = 2; ctx.strokeStyle = "#00ff00"; ctx.beginPath();
            const step = w / rawBuffer.length;
            for(let i=0; i<rawBuffer.length; i++) {
                const x = i*step; const y = mid - (rawBuffer[i]*scale);
                if(i===0) ctx.moveTo(x,y); else ctx.lineTo(x,y);
            }
            ctx.stroke();
            requestAnimationFrame(drawScope);
        }
        drawScope();

        // BLUETOOTH
        btn.addEventListener('click', async () => {
            try {
                statusBox.innerText = "Scanning...";
                const device = await navigator.bluetooth.requestDevice({
                    filters: [{ namePrefix: 'Mynd' }, { namePrefix: 'Mind' }, { namePrefix: 'Brain' }],
                    optionalServices: [HM10_SERVICE, OLD_SERVICE, "0000ffe0-0000-1000-8000-00805f9b34fb"]
                });

                const server = await device.gatt.connect();
                let service = null, cmdChar = null, dataChar = null;

                // TRY NATIVE (SPLIT) FIRST based on your success
                try {
                    service = await server.getPrimaryService(OLD_SERVICE);
                    const chars = await service.getCharacteristics();
                    cmdChar = chars.find(c => c.uuid.includes("fff4"));
                    dataChar = chars.find(c => c.uuid.includes("fff8"));
                    if(cmdChar && dataChar) log("‚úÖ Found Split Channels (fff4/fff8)");
                    else throw new Error("Missing chars");
                } catch(e) {
                    log("‚ö†Ô∏è Old Service failed, trying HM-10...");
                    service = await server.getPrimaryService(HM10_SERVICE);
                    const c = await service.getCharacteristic("0000ffe1-0000-1000-8000-00805f9b34fb");
                    cmdChar = c; dataChar = c;
                    log("‚úÖ Found HM-10 Unified Channel");
                }

                await dataChar.startNotifications();
                dataChar.addEventListener('characteristicvaluechanged', handleData);
                log("üëÇ Listening...");

                log("üöÄ Sending Unlock (0x02)...");
                const cmd = new Uint8Array([0x02]);
                if (cmdChar.properties.write) await cmdChar.writeValueWithResponse(cmd);
                else await cmdChar.writeValueWithoutResponse(cmd);
                log("‚úÖ Unlock Sent. Waiting for data...");
                
                statusBox.innerText = "Connected";
                statusBox.className = "connected";
                btn.disabled = true;

            } catch(e) { log("Error: " + e.message); }
        });

        // PARSER & SNIFFER
        let parseBuffer = [];
        function handleData(event) {
            const chunk = new Uint8Array(event.target.value.buffer);
            
            // --- SNIFFER: Log the first few packets in HEX ---
            if (sniffCount < 15) {
                const hex = Array.from(chunk).map(b => b.toString(16).padStart(2,'0').toUpperCase()).join(' ');
                log(`üì¶ [${chunk.length}B]: ${hex}`);
                sniffCount++;
            }
            // ------------------------------------------------

            for(let i=0; i<chunk.length; i++) parseBuffer.push(chunk[i]);
            processBuffer();
        }

        function processBuffer() {
            while (parseBuffer.length > 0) {
                const b = parseBuffer[0];
                
                // SYNC (AA AA)
                if (b === 0xAA) {
                    if (parseBuffer.length >= 2 && parseBuffer[1] === 0xAA) {
                        if (parseBuffer.length < 4) return;
                        const len = parseBuffer[2];
                        if (parseBuffer.length < 3 + len + 1) return;
                        parsePayload(parseBuffer.slice(3, 3+len));
                        parseBuffer.splice(0, 3 + len + 1);
                        continue;
                    } else {
                        if (parseBuffer.length < 2) return;
                        if (parseBuffer[1] !== 0xAA) { parseBuffer.shift(); continue; }
                    }
                } 
                // NAKED RAW (0x80)
                else if (b === 0x80) {
                    if (parseBuffer.length < 4) return;
                    if (parseBuffer[1] === 0x02) {
                        const val = (parseBuffer[2] << 8) | parseBuffer[3];
                        updateRaw(val);
                        parseBuffer.splice(0, 4);
                        continue;
                    } else { parseBuffer.shift(); continue; }
                }
                else { parseBuffer.shift(); }
            }
        }

        function parsePayload(payload) {
            let i = 0;
            while(i < payload.length) {
                const code = payload[i];
                if (code === 0x80) { // Raw in payload
                    const val = (payload[i+2] << 8) | payload[i+3];
                    updateRaw(val);
                    i += 4;
                } else if (code === 0x02) {
                    document.getElementById('sig-val').innerText = payload[i+1]; i+=2;
                } else if (code === 0x04) {
                    document.getElementById('att-val').innerText = payload[i+1]; i+=2;
                } else { i++; }
            }
        }

        function updateRaw(val) {
            if (val > 32768) val -= 65536;
            document.getElementById('last-raw').innerText = val;
            rawBuffer.shift();
            rawBuffer.push(val);
        }
    </script>
</body>
</html>
