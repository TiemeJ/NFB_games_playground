<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>MyndBand Manual Control</title>
    <style>
        body { font-family: 'Segoe UI', monospace; background: #2d3436; color: #dfe6e9; display: flex; flex-direction: column; align-items: center; padding: 20px; }
        h1 { margin: 0; color: #74b9ff; }
        .subtitle { color: #b2bec3; font-size: 0.9em; margin-bottom: 20px; }

        /* Signal Box */
        #sig-box { 
            padding: 10px 30px; border-radius: 8px; font-size: 20px; font-weight: bold; 
            margin-bottom: 20px; border: 2px solid #636e72; background: #2d3436; color: #b2bec3;
        }
        .sig-good { background: #00b894 !important; color: #000 !important; border-color: #00b894 !important; }

        /* Button Group */
        .controls { display: grid; grid-template-columns: 1fr 1fr; gap: 10px; margin-bottom: 20px; width: 100%; max-width: 600px; }
        button { 
            padding: 15px; font-size: 14px; font-weight: bold; border: none; border-radius: 8px; cursor: pointer; color: white; transition: 0.2s;
        }
        #connectBtn { grid-column: span 2; background: #0984e3; font-size: 18px; }
        .cmd-btn { background: #636e72; }
        .cmd-btn:hover { background: #b2bec3; color: #000; }
        .cmd-btn:active { transform: translateY(2px); }

        /* Scope */
        .scope-container { 
            background: #000; border: 2px solid #74b9ff; border-radius: 10px; 
            width: 100%; max-width: 800px; height: 300px; position: relative; 
        }
        canvas#rawScope { width: 100%; height: 100%; }
        .overlay { position: absolute; top: 10px; left: 15px; color: #74b9ff; font-size: 12px; pointer-events: none; }
        
        #log { width: 100%; max-width: 800px; height: 150px; background: #000; color: #0f0; padding: 10px; margin-top: 15px; overflow-y: auto; border: 1px solid #333; font-size: 11px; font-family: monospace; }
    </style>
</head>
<body>

    <h1>üéÆ MyndBand Manual Control</h1>
    <div class="subtitle">Prevent Browser Freezing with Manual Commands</div>

    <div id="sig-box">SIGNAL: --</div>

    <div class="controls">
        <button id="connectBtn">1. CONNECT</button>
        <button class="cmd-btn" onclick="sendCommand(0x02)">2. SEND UNLOCK (0x02)</button>
        <button class="cmd-btn" onclick="sendCommand(0x00)">3. SEND RESET (0x00)</button>
    </div>

    <div class="scope-container">
        <div class="overlay">RAW STREAM (512Hz)</div>
        <canvas id="rawScope"></canvas>
    </div>

    <div id="log">Waiting...</div>

    <script>
        // --- CONFIG ---
        const NATIVE_SERVICE = "039afff0-2c94-11e3-9e06-0002a5d5c51b";
        const HM10_SERVICE   = "0000ffe0-0000-1000-8000-00805f9b34fb";

        const logBox = document.getElementById('log');
        const sigBox = document.getElementById('sig-box');
        let writeChars = []; // Stores all writable endpoints
        let parseBuffer = [];

        function log(msg) {
            const t = new Date().toLocaleTimeString().split(' ')[0];
            logBox.innerHTML += `<div><span style="color:#555">[${t}]</span> ${msg}</div>`;
            logBox.scrollTop = logBox.scrollHeight;
        }

        // --- SCOPE VISUALIZER ---
        const canvas = document.getElementById('rawScope');
        const ctx = canvas.getContext('2d');
        let rawBuffer = new Array(512).fill(0);

        function resize() { canvas.width = canvas.offsetWidth; canvas.height = canvas.offsetHeight; }
        window.addEventListener('resize', resize); resize();

        function draw() {
            const w = canvas.width, h = canvas.height, mid = h/2, scale = h/1200;
            ctx.fillStyle = "rgba(0,0,0,1)"; 
            ctx.fillRect(0,0,w,h); // Hard clear for performance
            
            ctx.lineWidth = 2; ctx.strokeStyle = "#74b9ff"; ctx.beginPath();
            
            // Optimization: Skip points if buffer is huge
            const step = w/rawBuffer.length;
            for(let i=0; i<rawBuffer.length; i++) {
                const y = mid - (rawBuffer[i] * scale);
                if(i===0) ctx.moveTo(i*step, y); else ctx.lineTo(i*step, y);
            }
            ctx.stroke();
            requestAnimationFrame(draw);
        }
        draw();

        // --- BLUETOOTH ---
        document.getElementById('connectBtn').addEventListener('click', async () => {
            try {
                sigBox.innerText = "Scanning...";
                const device = await navigator.bluetooth.requestDevice({
                    filters: [{ namePrefix: 'Mynd' }, { namePrefix: 'Mind' }, { namePrefix: 'Brain' }],
                    optionalServices: [NATIVE_SERVICE, HM10_SERVICE, "0000ffe0-0000-1000-8000-00805f9b34fb"]
                });

                const server = await device.gatt.connect();
                log("‚úÖ Connected.");
                writeChars = []; // Reset targets

                // 1. Setup Native (fff4/fff8)
                try {
                    const svc = await server.getPrimaryService(NATIVE_SERVICE);
                    const chars = await svc.getCharacteristics();
                    
                    const cWrite = chars.find(c => c.uuid.includes("fff4"));
                    if(cWrite) { writeChars.push(cWrite); log("Target: Native Command (fff4)"); }
                    
                    const cData = chars.find(c => c.uuid.includes("fff8"));
                    if(cData) { 
                        writeChars.push(cData); // Sometimes we write here too
                        await cData.startNotifications();
                        cData.addEventListener('characteristicvaluechanged', handleData);
                        log("üëÇ Listening on fff8");
                    }
                } catch(e) { log("‚ö†Ô∏è Native setup issue: " + e.message); }

                // 2. Setup HM-10 (ffe1) - Backup
                try {
                    const svc = await server.getPrimaryService(HM10_SERVICE);
                    const c = await svc.getCharacteristic("0000ffe1-0000-1000-8000-00805f9b34fb");
                    if(c) {
                        writeChars.push(c);
                        await c.startNotifications(); // Listen here too just in case
                        c.addEventListener('characteristicvaluechanged', handleData);
                        log("Target: HM-10 (ffe1)");
                    }
                } catch(e) {}

                document.getElementById('connectBtn').innerText = "CONNECTED";
                document.getElementById('connectBtn').disabled = true;

            } catch(e) { log("‚ùå Error: " + e.message); }
        });

        // --- COMMAND SENDER ---
        async function sendCommand(byte) {
            if(writeChars.length === 0) { log("‚ùå No channels to write to!"); return; }
            
            const cmd = new Uint8Array([byte]);
            const hex = "0x" + byte.toString(16).padStart(2,'0').toUpperCase();
            log(`üöÄ Sending ${hex}...`);

            for(const char of writeChars) {
                try {
                    // Try WriteWithResponse first, fallback to Without
                    if(char.properties.write) await char.writeValueWithResponse(cmd);
                    else await char.writeValueWithoutResponse(cmd);
                } catch(e) {
                    console.log("Write failed on one channel", e);
                }
            }
        }

        // --- EFFICIENT PARSER (No Logs in Loop) ---
        function handleData(event) {
            const chunk = new Uint8Array(event.target.value.buffer);
            for(let i=0; i<chunk.length; i++) parseBuffer.push(chunk[i]);
            
            // Process max 10 packets per frame to prevent freezing
            let loops = 0;
            while(parseBuffer.length > 0 && loops < 50) {
                loops++;
                const b = parseBuffer[0];

                // Check for Raw (0x80)
                if(b === 0x80) {
                    if(parseBuffer.length < 4) break; // Wait for more data
                    if(parseBuffer[1] === 0x02) {
                        // Valid Raw Packet
                        const val = (parseBuffer[2] << 8) | parseBuffer[3];
                        pushToScope(val);
                        parseBuffer.splice(0, 4);
                        continue;
                    }
                }
                
                // Check for Sync (AA AA)
                if(b === 0xAA) {
                    if(parseBuffer.length >= 2 && parseBuffer[1] === 0xAA) {
                        if(parseBuffer.length < 4) break;
                        const len = parseBuffer[2];
                        if(parseBuffer.length < 3 + len + 1) break;
                        
                        // Parse Signal Quality only
                        const payload = parseBuffer.slice(3, 3+len);
                        for(let k=0; k<payload.length; k++) {
                            if(payload[k] === 0x02) updateSignal(payload[k+1]);
                        }
                        
                        parseBuffer.splice(0, 3 + len + 1);
                        continue;
                    } else if (parseBuffer.length >= 2) {
                        parseBuffer.shift(); continue;
                    } else break;
                }

                // Check for Wrapper (00 00 EA)
                if(b === 0x00 && parseBuffer.length >= 3 && parseBuffer[2] === 0xEA) {
                     if(parseBuffer.length >= 20) {
                        updateSignal(parseBuffer[6]); // Signal is usually at index 6
                        parseBuffer.splice(0, 20);
                     } else break;
                     continue;
                }

                parseBuffer.shift(); // Discard unknown byte
            }
        }

        function updateSignal(sig) {
            sigBox.innerText = `SIGNAL: ${sig}`;
            if(sig === 0) sigBox.classList.add('sig-good');
            else sigBox.classList.remove('sig-good');
        }

        function pushToScope(val) {
            if(val > 32768) val -= 65536;
            rawBuffer.shift();
            rawBuffer.push(val);
        }
    </script>
</body>
</html>
