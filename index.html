<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>MyndBand Auto-Unlocker</title>
    <style>
        body { font-family: 'Segoe UI', monospace; background: #1e272e; color: #d2dae2; display: flex; flex-direction: column; align-items: center; padding: 20px; }
        h1 { margin: 0; color: #00d2d3; text-shadow: 0 0 10px rgba(0,210,211,0.5); }
        .subtitle { color: #808e9b; font-size: 0.9em; margin-bottom: 20px; }
        
        /* Signal Indicator */
        #sig-box { 
            padding: 15px 30px; border-radius: 10px; font-size: 24px; font-weight: bold; 
            margin-bottom: 20px; text-align: center; border: 2px solid #576574;
            transition: all 0.3s ease;
        }
        .sig-off { background: #ff3f34; color: #fff; box-shadow: 0 0 15px #ff3f34; } /* 200 */
        .sig-ok  { background: #ffa801; color: #000; } /* 1-199 */
        .sig-good{ background: #0be881; color: #000; box-shadow: 0 0 15px #0be881; } /* 0 */

        button { padding: 15px 50px; font-size: 20px; font-weight: bold; background: #0984e3; color: white; border: none; border-radius: 50px; cursor: pointer; transition: 0.2s; box-shadow: 0 5px 15px rgba(0,0,0,0.3); }
        button:hover { transform: scale(1.05); background: #3498db; }
        button:disabled { background: #485460; transform: none; color: #808e9b; }

        /* Oscilloscope */
        .scope-container { 
            background: #000; border: 3px solid #485460; border-radius: 15px; 
            width: 100%; max-width: 900px; height: 350px; position: relative; 
            box-shadow: inset 0 0 20px rgba(0,0,0,0.8);
        }
        canvas#rawScope { width: 100%; height: 100%; display: block; }
        .scope-overlay { position: absolute; top: 10px; left: 15px; color: #00d2d3; font-size: 12px; pointer-events: none; }
        
        #log { width: 100%; max-width: 900px; height: 150px; background: #000; color: #0f0; padding: 10px; margin-top: 15px; overflow-y: scroll; border: 1px solid #333; font-size: 11px; }
    </style>
</head>
<body>

    <h1>ðŸ§  MyndBand Auto-Unlocker</h1>
    <div class="subtitle">1. Connect -> 2. Fit Headset -> 3. Wait for Green Signal</div>

    <div id="sig-box" class="sig-off">SIGNAL: --</div>
    <button id="connectBtn">CONNECT</button>

    <div class="scope-container">
        <div class="scope-overlay">RAW STREAM (512Hz)</div>
        <canvas id="rawScope"></canvas>
    </div>

    <pre id="log">Waiting...</pre>

    <script>
        const NATIVE_SERVICE = "039afff0-2c94-11e3-9e06-0002a5d5c51b";
        const HM10_SERVICE   = "0000ffe0-0000-1000-8000-00805f9b34fb";
        
        const btn = document.getElementById('connectBtn');
        const sigBox = document.getElementById('sig-box');
        const logBox = document.getElementById('log');
        
        let writeChar = null;
        let isRawUnlocked = false;
        let lastSignal = 200;
        let retryInterval = null;

        function log(msg) {
            const time = new Date().toLocaleTimeString().split(' ')[0];
            logBox.innerText += `\n[${time}] ${msg}`;
            logBox.scrollTop = logBox.scrollHeight;
        }

        // --- SCOPE VISUALIZER ---
        const canvas = document.getElementById('rawScope');
        const ctx = canvas.getContext('2d');
        let rawBuffer = new Array(512).fill(0);
        
        function resize() { canvas.width = canvas.offsetWidth; canvas.height = canvas.offsetHeight; }
        window.addEventListener('resize', resize); resize();

        function draw() {
            const w = canvas.width, h = canvas.height, mid = h/2, scale = h/1500;
            ctx.fillStyle = "rgba(0,0,0,0.2)"; // Trail effect
            ctx.fillRect(0,0,w,h);
            
            ctx.lineWidth = 2; 
            ctx.strokeStyle = isRawUnlocked ? "#0be881" : "#485460"; // Green if raw, gray if waiting
            ctx.beginPath();
            
            const step = w/rawBuffer.length;
            for(let i=0; i<rawBuffer.length; i++) {
                const y = mid - (rawBuffer[i] * scale);
                if(i===0) ctx.moveTo(i*step, y); else ctx.lineTo(i*step, y);
            }
            ctx.stroke();
            requestAnimationFrame(draw);
        }
        draw();

        // --- CONNECT ---
        btn.addEventListener('click', async () => {
            try {
                sigBox.innerText = "Scanning...";
                const device = await navigator.bluetooth.requestDevice({
                    filters: [{ namePrefix: 'Mynd' }, { namePrefix: 'Mind' }, { namePrefix: 'Brain' }],
                    optionalServices: [NATIVE_SERVICE, HM10_SERVICE, "0000ffe0-0000-1000-8000-00805f9b34fb"]
                });

                const server = await device.gatt.connect();
                log("Connected to GATT Server.");

                let service = null;
                let readChar = null;

                // TRY NATIVE SERVICE (Split Channels)
                try {
                    service = await server.getPrimaryService(NATIVE_SERVICE);
                    const chars = await service.getCharacteristics();
                    
                    // FFF4 = Command (Write)
                    writeChar = chars.find(c => c.uuid.includes("fff4"));
                    // FFF8 = Data (Notify)
                    readChar = chars.find(c => c.uuid.includes("fff8"));
                    
                    if(!writeChar || !readChar) throw new Error("Missing channels");
                    log("âœ… Found Native Channels (fff4/fff8)");
                    
                } catch(e) {
                    log("âš ï¸ Native failed, trying HM-10...");
                    // TRY HM-10 SERVICE (Unified)
                    service = await server.getPrimaryService(HM10_SERVICE);
                    const c = await service.getCharacteristic("0000ffe1-0000-1000-8000-00805f9b34fb");
                    writeChar = c;
                    readChar = c;
                    log("âœ… Found HM-10 Channel");
                }

                await readChar.startNotifications();
                readChar.addEventListener('characteristicvaluechanged', handleData);
                
                btn.disabled = true;
                btn.innerText = "Connected";
                
                // Start the "Unlock Nag" Loop
                startUnlockLoop();

            } catch(e) {
                log("Error: " + e.message);
                sigBox.innerText = "Error";
            }
        });

        // --- RETRY LOGIC ---
        function startUnlockLoop() {
            // Attempt to unlock every 2 seconds UNTIL we see raw data
            retryInterval = setInterval(async () => {
                if (isRawUnlocked) return; // Stop nagging if we have raw data

                if (lastSignal === 200) {
                    log("ðŸš« Signal 200 (Off Head). Waiting for contact...");
                    return; // Don't spam commands if off head
                }

                log("ðŸš€ Sending Unlock (0x02)...");
                try {
                    const cmd = new Uint8Array([0x02]);
                    if(writeChar.properties.write) await writeChar.writeValueWithResponse(cmd);
                    else await writeChar.writeValueWithoutResponse(cmd);
                } catch(e) { console.log(e); }
            }, 2000);
        }

        // --- PARSER ---
        let parseBuffer = [];

        function handleData(event) {
            const chunk = new Uint8Array(event.target.value.buffer);
            for(let i=0; i<chunk.length; i++) parseBuffer.push(chunk[i]);
            processBuffer();
        }

        function processBuffer() {
            while(parseBuffer.length > 0) {
                const b = parseBuffer[0];

                // 1. RAW MODE PACKET (0x80) -> SUCCESS!
                if (b === 0x80) {
                    if(parseBuffer.length < 4) return;
                    if(parseBuffer[1] === 0x02) {
                        // We are officially receiving raw data!
                        if (!isRawUnlocked) {
                            isRawUnlocked = true;
                            log("ðŸŽ‰ RAW MODE UNLOCKED! (512Hz Active)");
                            clearInterval(retryInterval); // Stop the nag loop
                        }
                        
                        const val = (parseBuffer[2] << 8) | parseBuffer[3];
                        updateScope(val);
                        parseBuffer.splice(0, 4);
                        continue;
                    }
                }
                
                // 2. STANDARD MODE PACKET (Sync AA AA)
                else if (b === 0xAA) {
                    if(parseBuffer.length >= 2 && parseBuffer[1] === 0xAA) {
                        if(parseBuffer.length < 4) return; // Wait for len
                        const len = parseBuffer[2];
                        if(parseBuffer.length < 3 + len + 1) return; // Wait for payload
                        
                        const payload = parseBuffer.slice(3, 3+len);
                        parseStandardPayload(payload);
                        
                        parseBuffer.splice(0, 3 + len + 1);
                        continue;
                    } else {
                        if(parseBuffer.length >= 2 && parseBuffer[1] !== 0xAA) { parseBuffer.shift(); continue; }
                        if(parseBuffer.length < 2) return;
                    }
                }
                
                // 3. MYNDBAND WRAPPER (00 00 EA...)
                else if (b === 0x00 && parseBuffer.length >= 3 && parseBuffer[2] === 0xEA) {
                     // 00 00 EA 00 00 02 [SIG]
                     if (parseBuffer.length >= 7) {
                        const sig = parseBuffer[6];
                        updateSignalUI(sig);
                        // We assume the rest of the packet is there and valid for now
                        // Just clearing the wrapper prefix to avoid stuck loops
                        parseBuffer.splice(0, 3); 
                     } else return;
                }

                // 4. Standalone Signal Byte (Sometimes sent by HM-10)
                else if (b === 0x02 && parseBuffer.length >= 2) {
                    // Check if next byte looks like signal (0-200)
                    if (parseBuffer[1] <= 200) {
                        updateSignalUI(parseBuffer[1]);
                        parseBuffer.splice(0, 2);
                        continue;
                    }
                }
                
                else {
                    parseBuffer.shift();
                }
            }
        }

        function parseStandardPayload(payload) {
            // Find Signal Byte (Code 0x02)
            for(let i=0; i<payload.length; i++) {
                if (payload[i] === 0x02) {
                    updateSignalUI(payload[i+1]);
                    return;
                }
            }
        }

        function updateSignalUI(sig) {
            lastSignal = sig;
            sigBox.innerText = `SIGNAL: ${sig}`;
            
            if (sig === 200) {
                sigBox.className = "sig-off";
                sigBox.innerText += " (Check Fit)";
            } else if (sig === 0) {
                sigBox.className = "sig-good";
                sigBox.innerText += " (Perfect)";
            } else {
                sigBox.className = "sig-ok";
                sigBox.innerText += " (Noise)";
            }
        }

        function updateScope(val) {
            if (val > 32768) val -= 65536;
            rawBuffer.shift();
            rawBuffer.push(val);
        }
    </script>
</body>
</html>
